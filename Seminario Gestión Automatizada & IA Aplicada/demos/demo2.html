<!DOCTYPE html>
<html lang="es">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Data Flow Architecture Final</title>
  <style>
    body {
      margin: 0;
      background: #050505;
      color: #ffffff;
      font-family: 'Segoe UI', monospace;
      overflow: hidden;
    }

    h1 {
      margin: 10px 0 5px 0;
      font-size: 24px;
      text-align: center;
      background: linear-gradient(90deg, #00ffcc, #3776AB);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .subtitle {
      text-align: center;
      color: #666;
      font-size: 12px;
      margin-bottom: 10px;
    }

    canvas {
      display: block;
      margin: 0 auto;
      background: #0a0a0a;
      border-top: 1px solid #222;
      border-bottom: 1px solid #222;
    }

    .legend {
      position: absolute;
      bottom: 60px;
      width: 100%;
      text-align: center;
      font-size: 11px;
      pointer-events: none;
    }

    .legend-item {
      display: inline-block;
      margin: 0 10px;
    }

    .legend-color {
      display: inline-block;
      width: 8px;
      height: 8px;
      margin-right: 4px;
      border-radius: 50%;
    }

    .controls {
      position: absolute;
      bottom: 20px;
      width: 100%;
      text-align: center;
    }

    button {
      background: transparent;
      color: #00ffcc;
      border: 1px solid #00ffcc;
      padding: 8px 20px;
      margin: 0 5px;
      cursor: pointer;
      font-family: 'Courier New', monospace;
      text-transform: uppercase;
      font-size: 12px;
      transition: 0.2s;
    }

    button:hover {
      background: #00ffcc;
      color: #000;
    }
  </style>
</head>

<body>
  <h1>Data Flow Architecture</h1>
  <p class="subtitle">PIPELINE DE PROCESAMIENTO Y VISUALIZACI√ìN</p>

  <canvas id="canvas"></canvas>



  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    // Configuraci√≥n Base
    let w, h;
    const resize = () => {
      w = canvas.width = window.innerWidth;
      h = canvas.height = window.innerHeight - 100;
    };
    window.addEventListener('resize', resize);
    resize();

    const getBoxCoords = () => {
      return {
        source: { x: w * 0.05, y: h * 0.15, w: w * 0.15, h: h * 0.70, label: "DATOS CRUDOS", icon: "üì•" },
        excel: { x: w * 0.28, y: h * 0.10, w: w * 0.15, h: h * 0.35, label: "EXCEL", sub: "Celdas", icon: "üìä" },
        db: { x: w * 0.28, y: h * 0.55, w: w * 0.15, h: h * 0.35, label: "DATABASE", sub: "Tablas", icon: "üóÑÔ∏è" },
        python: { x: w * 0.51, y: h * 0.15, w: w * 0.18, h: h * 0.70, label: "PYTHON", sub: "Processing...", icon: "üêç" },
        analysis: { x: w * 0.77, y: h * 0.10, w: w * 0.15, h: h * 0.35, label: "AN√ÅLISIS DE DATOS", sub: "Clasificaci√≥n", icon: "üîç" },
        charts: { x: w * 0.77, y: h * 0.55, w: w * 0.15, h: h * 0.35, label: "VISUALIZACI√ìN", sub: "Dashboard", icon: "üìà" }
      };
    };

    const COLORS = ["#00ffcc", "#ff6b6b", "#ffd43b", "#6c8cff"];
    const MAX_PARTICLES = 800;
    let particles = [];
    let animationRunning = true;
    let globalFrame = 0;
    let chartsTrigger = false; // Nueva bandera para activar gr√°ficos

    class Particle {
      constructor() {
        this.reset();
      }

      reset() {
        let boxes = getBoxCoords();
        this.x = boxes.source.x + 20 + Math.random() * (boxes.source.w - 40);
        this.y = boxes.source.y + 60 + Math.random() * (boxes.source.h - 80);

        this.tx = this.x;
        this.ty = this.y;
        this.color = COLORS[Math.floor(Math.random() * COLORS.length)];
        if (Math.random() < 0.05) this.color = "#ff2d2d";
        this.state = "source";

        // VELOCIDAD INICIAL MUY LENTA (Raw Input)
        this.speed = 0.008 + Math.random() * 0.004;
        this.size = 2.5;
        this.wait = Math.random() * 100;
        this.id = Math.random();
        this.analysisWaitTime = 0;
        this.stateTimer = 0; // Timer para controlar tiempo en cada estado
      }

      update(boxes) {
        if (this.wait > 0) { this.wait--; return; }

        switch (this.state) {
          case "source":
            this.stateTimer++;
            if (Math.abs(this.x - this.tx) < 2 && this.stateTimer > 60) { // +1 segundo (60 frames)
              this.state = Math.random() > 0.5 ? "excel" : "db";
              this.wait = 30;
              this.stateTimer = 0;
            } else {
              // Movimiento muy lento dentro de raw input
              this.tx = Math.max(boxes.source.x + 10, Math.min(boxes.source.x + boxes.source.w - 10, this.x + (Math.random() - 0.5) * 10));
              this.ty = Math.max(boxes.source.y + 60, Math.min(boxes.source.y + boxes.source.h - 10, this.y + (Math.random() - 0.5) * 10));
            }
            break;

          case "excel":
            this.stateTimer++;
            this.moveToGrid(boxes.excel, 5);
            this.speed = 0.01;
            if (this.reached() && this.stateTimer > 120) { // +2 segundos
              this.state = "python";
              this.wait = 40;
              this.stateTimer = 0;
            }
            break;

          case "db":
            this.stateTimer++;
            this.moveToTable(boxes.db);
            this.speed = 0.01;
            if (this.reached() && this.stateTimer > 120) { // +2 segundos
              this.state = "python";
              this.wait = 40;
              this.stateTimer = 0;
            }
            break;

          case "python":
            // AUMENTO DE VELOCIDAD AL ENTRAR A PYTHON
            this.speed = 0.04;
            this.processPython(boxes.python);
            if (globalFrame % 1500 === 0 && Math.random() > 0.1) {
              this.state = Math.random() > 0.6 ? "analysis" : "charts";
              if (this.state === "charts") chartsTrigger = true;
            }
            break;

          case "analysis":
            this.speed = 0.04; // Velocidad normal
            this.moveToSort(boxes.analysis);
            if (this.reached()) {
              // Esperar 1 segundo adicional (60 frames aprox)
              if (!this.analysisWaitTime) this.analysisWaitTime = 0;
              this.analysisWaitTime++;
              if (this.analysisWaitTime > 120) {
                this.fadeOut();
              }
            }
            break;

          case "charts":
            this.speed = 0.04; // Velocidad normal
            this.tx = boxes.charts.x + boxes.charts.w / 2;
            this.ty = boxes.charts.y + boxes.charts.h / 2;
            if (this.reached(10)) this.reset();
            break;
        }

        this.x += (this.tx - this.x) * this.speed;
        this.y += (this.ty - this.y) * this.speed;
      }

      moveToGrid(box, cols) {
        let index = Math.floor(this.id * 100);
        let safeW = box.w - 30;
        let safeH = box.h - 90;
        let cellW = safeW / cols;
        let cellH = 16;

        let col = index % cols;
        let row = Math.floor(index / cols);

        // L√≠mite de filas visibles
        let maxRows = Math.floor(safeH / cellH);
        if (row >= maxRows) row = row % maxRows;

        // Coordenadas dentro del cuadrado Excel (no centradas para efecto de celda)
        this.tx = box.x + 15 + col * cellW + 5;
        this.ty = box.y + 75 + row * cellH + 5;
      }

      moveToTable(box) {
        let index = Math.floor(this.id * 100);
        let cols = 4; // Menos columnas para efecto tabla SQL
        let col = index % cols;
        let row = Math.floor(index / cols);

        let safeW = box.w - 30;
        let safeH = box.h - 90;
        let cellW = safeW / cols;
        let cellH = 14;

        // L√≠mite de filas
        let maxRows = Math.floor(safeH / cellH);
        if (row >= maxRows) row = row % maxRows;

        // Tabla tipo registro/campo (alineaci√≥n izquierda en cada columna)
        let colOffset = col * cellW;
        let rowVariation = (this.id * 50) % (cellW - 10); // Simula longitud variable de datos

        this.tx = box.x + 15 + colOffset + rowVariation;
        this.ty = box.y + 75 + row * cellH + 5;
      }

      processPython(box) {
        let cx = box.x + box.w / 2;
        let cy = box.y + box.h / 2;
        let idx = Math.floor(this.id * 300);
        let cycle = Math.floor(globalFrame / 400) % 4; // 4 ciclos

        if (cycle === 0) { // Caos (Ingestion)
          this.speed = 0.05;
          this.tx = box.x + 20 + Math.random() * (box.w - 40);
          this.ty = box.y + 60 + Math.random() * (box.h - 80);
        } else if (cycle === 1) { // Cuadrado
          let side = Math.sqrt(200);
          let r = Math.floor(idx / side);
          let c = idx % side;
          let span = side * 10;
          let startX = cx - span / 2;
          let startY = cy - span / 2;
          this.tx = startX + c * 10;
          this.ty = startY + r * 10;
        } else if (cycle === 2) { // Lemniscata (‚àû)
          let radius = Math.min(box.w, box.h) * 0.25;
          let t = (idx / 300) * Math.PI * 2 + globalFrame * 0.01;
          let scale = radius / (1 + Math.sin(t) * Math.sin(t));
          this.tx = cx + scale * Math.cos(t);
          this.ty = cy + scale * Math.sin(t) * Math.cos(t);
        } else if (cycle === 3) { // Esfera
          let radius = Math.min(box.w, box.h) * 0.3;
          let layers = 15; // N√∫mero de capas conc√©ntricas
          let layer = Math.floor(Math.sqrt(idx / 5));
          let posInLayer = idx % (5 * (layer + 1));
          let angleOffset = (layer % 2) * (Math.PI / 5); // Rotaci√≥n alternada
          let angle = (posInLayer / (5 * (layer + 1))) * Math.PI * 2 + angleOffset;
          let r = (radius / layers) * (layer + 1);
          this.tx = cx + r * Math.cos(angle - Math.PI / 2);
          this.ty = cy + r * Math.sin(angle - Math.PI / 2);
        }
      }

      moveToSort(box) {
        let typeIndex = COLORS.indexOf(this.color);
        if (this.color === "#ff2d2d") typeIndex = 4;

        let colW = (box.w - 20) / 5;
        let xPos = box.x + 10 + typeIndex * colW + colW / 2;
        let stackHeight = (this.id * 100) % (box.h - 80);

        this.tx = xPos;
        this.ty = (box.y + box.h - 20) - stackHeight;
      }

      reached(dist = 4) {
        return Math.abs(this.x - this.tx) < dist && Math.abs(this.y - this.ty) < dist;
      }

      fadeOut() {
        this.size -= 0.05;
        if (this.size <= 0) {
          this.reset();
          this.analysisWaitTime = 0; // Reset del timer
        }
      }

      draw() {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    for (let i = 0; i < MAX_PARTICLES; i++) particles.push(new Particle());

    function roundRect(x, y, w, h, radius, color) {
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + w - radius, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + radius);
      ctx.lineTo(x + w, y + h - radius);
      ctx.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
      ctx.lineTo(x + radius, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();

      ctx.fillStyle = "rgba(10, 10, 15, 0.9)";
      ctx.shadowBlur = 10;
      ctx.shadowColor = color;
      ctx.fill();
      ctx.lineWidth = 1;
      ctx.strokeStyle = color;
      ctx.stroke();
      ctx.shadowBlur = 0;
    }

    function drawLabels(x, y, w, h, label, sub, icon) {
      ctx.fillStyle = "#fff";
      ctx.textAlign = "center";
      ctx.font = "24px Arial";
      ctx.fillText(icon, x + w / 2, y + 30);
      ctx.font = "bold 11px 'Segoe UI'"; // Reducido para textos m√°s largos
      ctx.fillText(label, x + w / 2, y + 50);
      if (sub) {
        ctx.fillStyle = "#888";
        ctx.font = "10px monospace";
        ctx.fillText(sub, x + w / 2, y + 65);
      }
    }

    function drawExcelGrid(box) {
      ctx.strokeStyle = "rgba(45, 122, 62, 0.3)";
      ctx.lineWidth = 0.5;

      let cols = 5;
      let safeW = box.w - 30;
      let safeH = box.h - 90;
      let cellW = safeW / cols;
      let cellH = 16;
      let startY = box.y + 75;
      let startX = box.x + 15;

      // L√≠neas verticales
      for (let i = 0; i <= cols; i++) {
        ctx.beginPath();
        ctx.moveTo(startX + i * cellW, startY);
        ctx.lineTo(startX + i * cellW, startY + safeH);
        ctx.stroke();
      }

      // L√≠neas horizontales
      let rows = Math.floor(safeH / cellH);
      for (let i = 0; i <= rows; i++) {
        ctx.beginPath();
        ctx.moveTo(startX, startY + i * cellH);
        ctx.lineTo(startX + safeW, startY + i * cellH);
        ctx.stroke();
      }
    }

    function drawDatabaseTable(box) {
      ctx.strokeStyle = "rgba(55, 118, 171, 0.3)";
      ctx.lineWidth = 0.5;

      let cols = 4;
      let safeW = box.w - 30;
      let safeH = box.h - 90;
      let cellW = safeW / cols;
      let cellH = 14;
      let startY = box.y + 75;
      let startX = box.x + 15;

      // L√≠neas verticales (columnas)
      for (let i = 0; i <= cols; i++) {
        ctx.beginPath();
        ctx.moveTo(startX + i * cellW, startY);
        ctx.lineTo(startX + i * cellW, startY + safeH);
        ctx.stroke();
      }

      // Header row (m√°s grueso)
      ctx.strokeStyle = "rgba(55, 118, 171, 0.6)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(startX, startY);
      ctx.lineTo(startX + safeW, startY);
      ctx.stroke();

      // Etiquetas de campos
      ctx.fillStyle = "rgba(255, 255, 255, 0.4)";
      ctx.font = "8px monospace";
      ctx.textAlign = "center";
      let fields = ["ID", "NAME", "VALUE", "STATUS"];
      for (let i = 0; i < cols; i++) {
        ctx.fillText(fields[i], startX + i * cellW + cellW / 2, startY - 3);
      }

      // L√≠neas horizontales (registros)
      ctx.strokeStyle = "rgba(55, 118, 171, 0.2)";
      ctx.lineWidth = 0.5;
      let rows = Math.floor(safeH / cellH);
      for (let i = 1; i <= rows; i++) {
        ctx.beginPath();
        ctx.moveTo(startX, startY + i * cellH);
        ctx.lineTo(startX + safeW, startY + i * cellH);
        ctx.stroke();
      }
    }

    function drawSimulatedCharts(box) {
      if (!chartsTrigger) return; // No dibujar hasta que se active

      const topY = box.y + 90;
      const usableH = box.h - 100;
      const usableW = box.w - 20;
      const midX = box.x + box.w / 2;
      const midY = topY + usableH / 2;
      const sFrame = globalFrame * 0.02;

      ctx.lineWidth = 1.5;

      // -- Top Left: Pie Chart --
      const r = Math.min(usableW, usableH) * 0.15;
      const cx1 = box.x + usableW * 0.25 + 10;
      const cy1 = topY + usableH * 0.25;
      let start = 0;
      [0.4, 0.3, 0.2, 0.1].forEach((val, i) => {
        ctx.beginPath();
        ctx.moveTo(cx1, cy1);
        ctx.arc(cx1, cy1, r, start, start + val * Math.PI * 2);
        ctx.fillStyle = COLORS[i];
        ctx.fill();
        start += val * Math.PI * 2;
      });

      // -- Top Right: Bar Chart --
      const cx2 = midX + 10;
      const cy2 = cy1 + r;
      const barW = (usableW * 0.4) / 5;
      for (let i = 0; i < 4; i++) {
        let h = 10 + Math.abs(Math.sin(sFrame + i)) * 30;
        ctx.fillStyle = COLORS[i];
        ctx.fillRect(cx2 + i * (barW + 2), cy2 - h, barW, h);
      }

      // -- Bottom Left: Line Chart --
      const cx3 = box.x + 15;
      const cy3 = midY + 10;
      const w3 = usableW * 0.45;
      const h3 = usableH * 0.4;

      ctx.beginPath();
      ctx.strokeStyle = "#00ffcc";
      for (let i = 0; i < w3; i += 5) {
        let y = (cy3 + h3 / 2) + Math.sin(i * 0.1 + sFrame) * (h3 * 0.3);
        if (i === 0) ctx.moveTo(cx3 + i, y); else ctx.lineTo(cx3 + i, y);
      }
      ctx.stroke();

      // -- Bottom Right: Area Chart --
      const cx4 = midX + 10;
      const cy4 = midY + 10;
      const w4 = w3;
      const h4 = h3;

      ctx.beginPath();
      ctx.fillStyle = "rgba(108, 140, 255, 0.3)";
      ctx.moveTo(cx4, cy4 + h4);

      for (let i = 0; i <= w4; i += 4) {
        let val = Math.sin(i * 0.15 + sFrame * 1.5) * (h4 * 0.4);
        let py = (cy4 + h4 / 2) - val;
        ctx.lineTo(cx4 + i, py);
      }
      ctx.lineTo(cx4 + w4, cy4 + h4);
      ctx.lineTo(cx4, cy4 + h4);
      ctx.fill();

      ctx.beginPath();
      ctx.strokeStyle = "#6c8cff";
      for (let i = 0; i <= w4; i += 4) {
        let val = Math.sin(i * 0.15 + sFrame * 1.5) * (h4 * 0.4);
        let py = (cy4 + h4 / 2) - val;
        if (i === 0) ctx.moveTo(cx4 + i, py); else ctx.lineTo(cx4 + i, py);
      }
      ctx.stroke();
    }

    function animate() {
      if (!animationRunning) return;
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      let boxes = getBoxCoords();

      // Fondos
      roundRect(boxes.source.x, boxes.source.y, boxes.source.w, boxes.source.h, 12, "#555");
      roundRect(boxes.excel.x, boxes.excel.y, boxes.excel.w, boxes.excel.h, 12, "#2d7a3e");
      roundRect(boxes.db.x, boxes.db.y, boxes.db.w, boxes.db.h, 12, "#3776AB");
      roundRect(boxes.python.x, boxes.python.y, boxes.python.w, boxes.python.h, 12, "#ffd43b");
      roundRect(boxes.analysis.x, boxes.analysis.y, boxes.analysis.w, boxes.analysis.h, 12, "#9b59b6");
      roundRect(boxes.charts.x, boxes.charts.y, boxes.charts.w, boxes.charts.h, 12, "#e67e22");

      // Grids y estructuras
      drawExcelGrid(boxes.excel);
      drawDatabaseTable(boxes.db);

      // Gr√°ficos
      drawSimulatedCharts(boxes.charts);

      // Part√≠culas
      particles.forEach(p => {
        p.update(boxes);
        p.draw();
      });

      // Textos
      drawLabels(boxes.source.x, boxes.source.y, boxes.source.w, boxes.source.h, boxes.source.label, "", boxes.source.icon);
      drawLabels(boxes.excel.x, boxes.excel.y, boxes.excel.w, boxes.excel.h, boxes.excel.label, boxes.excel.sub, boxes.excel.icon);
      drawLabels(boxes.db.x, boxes.db.y, boxes.db.w, boxes.db.h, boxes.db.label, boxes.db.sub, boxes.db.icon);

      let cycle = Math.floor(globalFrame / 400) % 4;
      let pyStatus = ["Ingesti√≥n de datos", "Matriz Cuadrada", "Lemniscata", "Esfera"][cycle];
      drawLabels(boxes.python.x, boxes.python.y, boxes.python.w, boxes.python.h, boxes.python.label, pyStatus, boxes.python.icon);

      drawLabels(boxes.analysis.x, boxes.analysis.y, boxes.analysis.w, boxes.analysis.h, boxes.analysis.label, boxes.analysis.sub, boxes.analysis.icon);
      drawLabels(boxes.charts.x, boxes.charts.y, boxes.charts.w, boxes.charts.h, boxes.charts.label, boxes.charts.sub, boxes.charts.icon);

      globalFrame++;
      requestAnimationFrame(animate);
    }

    function toggleAnimation() { animationRunning = !animationRunning; if (animationRunning) animate(); }
    function resetAnimation() { particles.forEach(p => p.reset()); globalFrame = 0; chartsTrigger = false; }

    animate();
  </script>
</body>

</html>